<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Type_system (mini_ml.Language.Type_system)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">mini_ml</a> &#x00BB; <a href="../index.html">Language</a> &#x00BB; Type_system</nav><header class="odoc-preamble"><h1>Module <code><span>Language.Type_system</span></code></h1><p>This module defines a lot of utilitary functions used to deal with types that are provided to (and hidden from) you. You will need these functions for implementing the different versions of the typer.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec value anchored" id="val-get_type_generic"><a href="#val-get_type_generic" class="anchor"></a><code><span><span class="keyword">val</span> get_type_generic : <span><a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p>Get the list of generalized universal type of a type, i.e., the list associated to a type <a href="../Ast/index.html#type-type_lang.TFunc"><code>Ast.type_lang.TFunc</code></a> or <a href="../Ast/index.html#type-type_lang.TList"><code>Ast.type_lang.TList</code></a>. Empty for all other types. For example, <code>get_type_generic (TFunc([1],TUniv 1,TUniv 0))</code> will return <code>[1]</code>.</p><p>(I don't need it in my implementation, but should you need it, I leave it available).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_free_type_var"><a href="#val-get_free_type_var" class="anchor"></a><code><span><span class="keyword">val</span> get_free_type_var : <span><a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div><div class="spec-doc"><p>Get the list of universal type that are unbound by a generalization. For example <code>get_free_type_var (TFunc([1],TUniv 1, TUniv 0))</code> will return <code>[0]</code>, as <code>1</code> is bound within the type.</p><p>This function is useful for implementing <a href="../Typer_util/index.html#val-solve_constraints"><code>Typer_util.solve_constraints</code></a>(when you need to determine whether a constraint of the form <code>TUniv(n),t</code>) is solvable).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-apply_subst_in_type"><a href="#val-apply_subst_in_type" class="anchor"></a><code><span><span class="keyword">val</span> apply_subst_in_type : 
  <span><span><span>(int * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a></span></code></div><div class="spec-doc"><p><code>apply_subst_in_type subst target</code> will successively apply all substitution in <code>subst</code> (with <code>substitute_univ_in_type</code> to <code>target</code> and return the result).</p><p>For example, <code>apply_subst_in_type [(0,TUniv 1);(1,TInt)] (TFunc([],TFunc([],TUniv 0,TUniv 2),TUniv 1))</code> will return <code>TFunc([],TFunc([],TInt,TUniv 2),TInt)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-substitute_constraint"><a href="#val-substitute_constraint" class="anchor"></a><code><span><span class="keyword">val</span> substitute_constraint : 
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a></span></code></div><div class="spec-doc"><p><code>substitute_constraint num typ (c1,c2)</code> replaces any occurrence of <code>TUniv(num)</code> with <code>t</code> in <code>c1</code> and <code>c2</code> and returns the resulting constraint. (similarly as what is above)</p><p>This function will only be useful when implementing <a href="../Typer_util/index.html#val-solve_constraints"><code>Typer_util.solve_constraints</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split_constraint_by_floor"><a href="#val-split_constraint_by_floor" class="anchor"></a><code><span><span class="keyword">val</span> split_constraint_by_floor : 
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a>)</span> list</span> * <span><span>(<a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a>)</span> list</span></span></code></div><div class="spec-doc"><p><code>split_constraint_by_floor floor list</code> will separate the list of constraints <code>list</code> into <code>inner,outer</code>, <code>inner</code> being the constraints who contain some occurrence of universal variable higher than floor or no universal variable, and <code>outer</code> the constraint that concern some universal variable strictly lower than <code>floor</code>.</p><p><code>inner</code> are the constraints that should be solved in a let declaration, while <code>outer</code> are those who should be solved in the containing expression (because they will have impact on those).</p><p>This function will only be useful for the fully polymorphic typer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_substitution_in_expr"><a href="#val-type_substitution_in_expr" class="anchor"></a><code><span><span class="keyword">val</span> type_substitution_in_expr : <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(int * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>type_substitution_in_expr expr substitution</code> applies the type substitution <code>substitution</code> to all annotations present in <code>expr</code>. If <code>expr</code> is not already typed, does nothing.</p><p>For example, if the substitution contains <code>(1,TInt)</code>, it will replace any occurrence of type <code>TUniv 1</code> with <code>TInt</code>.</p><p>You will only have to use it explicitly for the fully polymorphic typer (for the weak one, it is called for you in main).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-generalize_type_expr"><a href="#val-generalize_type_expr" class="anchor"></a><code><span><span class="keyword">val</span> generalize_type_expr : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-expr">Ast.expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a></span></code></div><div class="spec-doc"><p><code>generalize_type_expr floor expr</code> generalizes every universal variable of index higher than <code>floor</code> present in the type annotating <code>expr</code>. Expects <code>expr</code> to have a type annotation, and will raise an exception if it is not the case.</p><p>You will only have to use it for the fully polymorphic typer (for the weak one, it is not useful).</p></div></div></div></body></html>
