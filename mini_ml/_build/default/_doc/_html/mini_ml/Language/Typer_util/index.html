<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Typer_util (mini_ml.Language.Typer_util)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">mini_ml</a> &#x00BB; <a href="../index.html">Language</a> &#x00BB; Typer_util</nav><header class="odoc-preamble"><h1>Module <code><span>Language.Typer_util</span></code></h1><p>This module contains function that are useful to the different typers we will implement, and that you'll have to implement</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec exception anchored" id="exception-Constraint_error"><a href="#exception-Constraint_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Constraint_error</span> <span class="keyword">of</span> <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a></span></code></div><div class="spec-doc"><p>Exception that can be returned when a constraint cannot be solved -- it should be catched where you call <a href="#val-solve_constraints"><code>solve_constraints</code></a></p></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Typing_error"><a href="#exception-Typing_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Typing_error</span> <span class="keyword">of</span> <a href="../../Util/Position/index.html#type-t">Util.Position.t</a> * string</span></code></div><div class="spec-doc"><p>Exception that can be returned in case a typing error occurs. The position is the position of the term in which the error occurs (for pretty-printing), and the string is an explanation of the error returned.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Counter"><a href="#module-Counter" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Counter/index.html">Counter</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Technical module to represent a counter that can create fresh values when needed. Used for creating new universal types when needed</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-type_of_built_in"><a href="#val-type_of_built_in" class="anchor"></a><code><span><span class="keyword">val</span> type_of_built_in : <span><a href="../Ast/index.html#type-built_in">Ast.built_in</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a></span></code></div><div class="spec-doc"><p>Function that returns the type of every built-in function of mini-ml. See <a href="../Ast/index.html"><code>Ast</code></a> for the type to put here.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-solve_constraints"><a href="#val-solve_constraints" class="anchor"></a><code><span><span class="keyword">val</span> solve_constraints : 
  <span><span><span>(<a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int * <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a>)</span> list</span></span></code></div><div class="spec-doc"><p>Function that solves a list of constraints and produces the resulting substitution. Treats each constraint sequentially. The principle is the following : if a constraint is not solvable, raises a <a href="#exception-Constraint_error"><code>Constraint_error</code></a> ; otherwise, compute the corresponding substitution (see below), apply it to the rest of the list of constraints, and then solve them. The solvable constraints are :</p><ul><li>(TUniv n,t) or (t,TUniv n) : only if t does not contain TUniv n. In that case, the substitution is (n,t). If t is TUniv m, we replace the bigger variable with the smaller one.</li><li>(TFunc(_,arg1,res1),TFunc(_,arg2,res2)). In that case, we do not have a direct substitution, but we need to solve in addition the constraints (arg1,arg2) and (res1,res2).</li><li>TList(_,t1),TList(_t2). Similarly, here we have to solve the constraint (t1,t2).</li><li>(t1,t2). If t1 = t2, the constraint is solvable, and we have no substitution to add (as there are constant types) to the result returned by the remainder of the constraints. If not, this is an error case.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-instantiate"><a href="#val-instantiate" class="anchor"></a><code><span><span class="keyword">val</span> instantiate : <span><a href="Counter/index.html#type-t">Counter.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Ast/index.html#type-type_lang">Ast.type_lang</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Ast/index.html#type-type_lang">Ast.type_lang</a></span></code></div><div class="spec-doc"><p><code>instantiate counter target</code> replace any universal type that are generalized in <code>target</code> with fresh (unused) universal type. For example, if we have <code>instantiate counter (TFunc([1],TUniv 0,TUniv 1))</code>, it will return <code>TFunc([],TUniv 0,TUniv n)</code> where <code>n</code> will be the value returned by <code>counter</code>.</p></div></div></div></body></html>
