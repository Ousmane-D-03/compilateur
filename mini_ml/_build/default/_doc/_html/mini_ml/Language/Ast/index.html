<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast (mini_ml.Language.Ast)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">mini_ml</a> &#x00BB; <a href="../index.html">Language</a> &#x00BB; Ast</nav><header class="odoc-preamble"><h1>Module <code><span>Language.Ast</span></code></h1><p>This module defines the language mini-ml that we compile in this project, alongside some display functions, annotations containing parsing and type information, and functions used for applying type substitution to an already typed expression (useful for the typer)</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-type_lang"><a href="#type-type_lang" class="anchor"></a><code><span><span class="keyword">type</span> type_lang</span><span> = </span></code><ol><li id="type-type_lang.TInt" class="def variant constructor anchored"><a href="#type-type_lang.TInt" class="anchor"></a><code><span>| </span><span><span class="constructor">TInt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>int type</p><span class="comment-delim">*)</span></div></li><li id="type-type_lang.TBool" class="def variant constructor anchored"><a href="#type-type_lang.TBool" class="anchor"></a><code><span>| </span><span><span class="constructor">TBool</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>bool type</p><span class="comment-delim">*)</span></div></li><li id="type-type_lang.TString" class="def variant constructor anchored"><a href="#type-type_lang.TString" class="anchor"></a><code><span>| </span><span><span class="constructor">TString</span></span></code></li><li id="type-type_lang.TUnit" class="def variant constructor anchored"><a href="#type-type_lang.TUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">TUnit</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>unit type (action)</p><span class="comment-delim">*)</span></div></li><li id="type-type_lang.TFunc" class="def variant constructor anchored"><a href="#type-type_lang.TFunc" class="anchor"></a><code><span>| </span><span><span class="constructor">TFunc</span> <span class="keyword">of</span> <span>int list</span> * <a href="#type-type_lang">type_lang</a> * <a href="#type-type_lang">type_lang</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>function type. Functions have only one parameter (function with several parameters ar represented by a function of the first parameter that has a function (with the remaining parameters) as a result). <code>TFunc(generic,param,result)</code> represents a function where <code>param</code> is the type of the parameter, <code>result</code> is the type of the result, and <code>generic</code> is the list of universal types that are generalized (i.e., which can be different for each call of the function). <code>generic</code> will be non-empty only for functions that are bound by a let. For example, the type 'a -&gt; 'b -&gt; 'a will be represented by <code>TFunc([0;1],TUniv(0),TFunc([],TUniv(1),TUniv(0)))</code></p><span class="comment-delim">*)</span></div></li><li id="type-type_lang.TList" class="def variant constructor anchored"><a href="#type-type_lang.TList" class="anchor"></a><code><span>| </span><span><span class="constructor">TList</span> <span class="keyword">of</span> <span>int list</span> * <a href="#type-type_lang">type_lang</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>list type. <code>TList(generic,t)</code> represents a list of type <code>t</code> list. <code>generic</code> is the list of universal types that are generalized. For example, the empty list is of type <code>TList([0],TUniv 0)</code></p><span class="comment-delim">*)</span></div></li><li id="type-type_lang.TUniv" class="def variant constructor anchored"><a href="#type-type_lang.TUniv" class="anchor"></a><code><span>| </span><span><span class="constructor">TUniv</span> <span class="keyword">of</span> int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>universal type, i.e. a type that can be replaced by any other type in a concrete execution. Represented as integer, but displayed as letter : <code>TUniv 0</code> is displayed as <code>'a</code>, <code>TUniv 1</code> as <code>'b</code>, etc.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Type representing the possible types of a mini-ml expression</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-string_of_type_lang"><a href="#val-string_of_type_lang" class="anchor"></a><code><span><span class="keyword">val</span> string_of_type_lang : <span><a href="#type-type_lang">type_lang</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Gets a string representation of a type.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Annotation"><a href="#module-Annotation" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Annotation/index.html">Annotation</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module representing annotations of expressions (i.e., AST nodes, which are the only one relevant here). Contains :</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-built_in"><a href="#type-built_in" class="anchor"></a><code><span><span class="keyword">type</span> built_in</span><span> = </span></code><ol><li id="type-built_in.Add" class="def variant constructor anchored"><a href="#type-built_in.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Addition of integers : int -&gt; int -&gt; int</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Sub" class="def variant constructor anchored"><a href="#type-built_in.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Substraction of integers : int -&gt; int -&gt; int</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Mul" class="def variant constructor anchored"><a href="#type-built_in.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Multiplication of integers : int -&gt; int -&gt; int</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Div" class="def variant constructor anchored"><a href="#type-built_in.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Quotient of integers : int -&gt; int -&gt; int</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Mod" class="def variant constructor anchored"><a href="#type-built_in.Mod" class="anchor"></a><code><span>| </span><span><span class="constructor">Mod</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Modulus of integers : int -&gt; int -&gt; int</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.And" class="def variant constructor anchored"><a href="#type-built_in.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean and : bool -&gt; bool -&gt; bool</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Or" class="def variant constructor anchored"><a href="#type-built_in.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean or : bool -&gt; bool -&gt; bool</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Eq" class="def variant constructor anchored"><a href="#type-built_in.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Equality : 'a -&gt; 'a -&gt; bool</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Neq" class="def variant constructor anchored"><a href="#type-built_in.Neq" class="anchor"></a><code><span>| </span><span><span class="constructor">Neq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Difference : 'a -&gt; 'a -&gt; bool</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Lt" class="def variant constructor anchored"><a href="#type-built_in.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Strictly less : 'a -&gt; 'a -&gt; bool</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Gt" class="def variant constructor anchored"><a href="#type-built_in.Gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Gt</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Strictly greater : 'a -&gt; 'a -&gt; bool</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Leq" class="def variant constructor anchored"><a href="#type-built_in.Leq" class="anchor"></a><code><span>| </span><span><span class="constructor">Leq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Less or equal : 'a -&gt; 'a -&gt; bool</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Geq" class="def variant constructor anchored"><a href="#type-built_in.Geq" class="anchor"></a><code><span>| </span><span><span class="constructor">Geq</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Greater or equal : 'a -&gt; 'a -&gt; bool</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Concat" class="def variant constructor anchored"><a href="#type-built_in.Concat" class="anchor"></a><code><span>| </span><span><span class="constructor">Concat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String concatenation : string -&gt; string -&gt; string</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Cat" class="def variant constructor anchored"><a href="#type-built_in.Cat" class="anchor"></a><code><span>| </span><span><span class="constructor">Cat</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List catenation : 'a -&gt; 'a list -&gt; 'a list</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Append" class="def variant constructor anchored"><a href="#type-built_in.Append" class="anchor"></a><code><span>| </span><span><span class="constructor">Append</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List append : 'a list -&gt; 'a list -&gt; 'a list</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.UMin" class="def variant constructor anchored"><a href="#type-built_in.UMin" class="anchor"></a><code><span>| </span><span><span class="constructor">UMin</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unary int minus : int -&gt; int</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Not" class="def variant constructor anchored"><a href="#type-built_in.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean negation : bool -&gt; bool</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Head" class="def variant constructor anchored"><a href="#type-built_in.Head" class="anchor"></a><code><span>| </span><span><span class="constructor">Head</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List head : 'a list -&gt; 'a</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Tail" class="def variant constructor anchored"><a href="#type-built_in.Tail" class="anchor"></a><code><span>| </span><span><span class="constructor">Tail</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>List tail : 'a list -&gt; 'a list</p><span class="comment-delim">*)</span></div></li><li id="type-built_in.Print" class="def variant constructor anchored"><a href="#type-built_in.Print" class="anchor"></a><code><span>| </span><span><span class="constructor">Print</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Print function : 'a -&gt; unit</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Type representing the built-in function of the mini-ml language (both binary and unary). We also precise their type (universal types are generalised).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.Cst_i" class="def variant constructor anchored"><a href="#type-expr.Cst_i" class="anchor"></a><code><span>| </span><span><span class="constructor">Cst_i</span> <span class="keyword">of</span> int * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integer constant</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Cst_b" class="def variant constructor anchored"><a href="#type-expr.Cst_b" class="anchor"></a><code><span>| </span><span><span class="constructor">Cst_b</span> <span class="keyword">of</span> bool * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Boolean constant</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Cst_str" class="def variant constructor anchored"><a href="#type-expr.Cst_str" class="anchor"></a><code><span>| </span><span><span class="constructor">Cst_str</span> <span class="keyword">of</span> string * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String constant</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Cst_func" class="def variant constructor anchored"><a href="#type-expr.Cst_func" class="anchor"></a><code><span>| </span><span><span class="constructor">Cst_func</span> <span class="keyword">of</span> <a href="#type-built_in">built_in</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Built-in function constant</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Nil" class="def variant constructor anchored"><a href="#type-expr.Nil" class="anchor"></a><code><span>| </span><span><span class="constructor">Nil</span> <span class="keyword">of</span> <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Empty list constant</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Unit" class="def variant constructor anchored"><a href="#type-expr.Unit" class="anchor"></a><code><span>| </span><span><span class="constructor">Unit</span> <span class="keyword">of</span> <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unit (empty action) constant</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Var" class="def variant constructor anchored"><a href="#type-expr.Var" class="anchor"></a><code><span>| </span><span><span class="constructor">Var</span> <span class="keyword">of</span> string * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variable</p><span class="comment-delim">*)</span></div></li><li id="type-expr.IfThenElse" class="def variant constructor anchored"><a href="#type-expr.IfThenElse" class="anchor"></a><code><span>| </span><span><span class="constructor">IfThenElse</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>If then else expression</p><span class="comment-delim">*)</span></div></li><li id="type-expr.App" class="def variant constructor anchored"><a href="#type-expr.App" class="anchor"></a><code><span>| </span><span><span class="constructor">App</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function application (one argument)</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Let" class="def variant constructor anchored"><a href="#type-expr.Let" class="anchor"></a><code><span>| </span><span><span class="constructor">Let</span> <span class="keyword">of</span> bool * string * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let in binding expression (the boolean is true if it is a recursive let)</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Fun" class="def variant constructor anchored"><a href="#type-expr.Fun" class="anchor"></a><code><span>| </span><span><span class="constructor">Fun</span> <span class="keyword">of</span> string * <a href="#type-expr">expr</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function definition (one parameter)</p><span class="comment-delim">*)</span></div></li><li id="type-expr.Ignore" class="def variant constructor anchored"><a href="#type-expr.Ignore" class="anchor"></a><code><span>| </span><span><span class="constructor">Ignore</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="Annotation/index.html#type-t">Annotation.t</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Expression sequencing (ignoring value of first expression)</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Type representing a mini-ml expression</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-req"><a href="#type-req" class="anchor"></a><code><span><span class="keyword">type</span> req</span><span> = bool * string * <a href="#type-expr">expr</a></span></code></div><div class="spec-doc"><p>Type representing a top-level request (a let request)</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span><a href="#type-req">req</a> list</span></span></code></div><div class="spec-doc"><p>Type of a mini-ml program, i.e., a list of <a href="#type-req"><code>req</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy_expr"><a href="#val-copy_expr" class="anchor"></a><code><span><span class="keyword">val</span> copy_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-expr">expr</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_expr_annotation"><a href="#val-get_expr_annotation" class="anchor"></a><code><span><span class="keyword">val</span> get_expr_annotation : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="Annotation/index.html#type-t">Annotation.t</a></span></code></div><div class="spec-doc"><p><code>get_expr_annotation expr</code> returns the annotation contained in the expression. Useful for accessing them outside of a pattern-matching.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_expr"><a href="#val-pp_expr" class="anchor"></a><code><span><span class="keyword">val</span> pp_expr : <span>bool <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty printer of an expression. <code>pp_expr extended_syntax print_types fmt expr</code> displays a text representation of <code>expr</code> on formatter <code>fmt</code>. If <code>extended_syntax</code> is true, will use extended OCaml-like syntax, otherwise, raw minimal syntax. If <code>print_types</code> is true, will annotate variables with their types if they are set.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_req"><a href="#val-pp_req" class="anchor"></a><code><span><span class="keyword">val</span> pp_req : <span>bool <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-req">req</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty printer of a request, see <a href="#val-pp_expr"><code>pp_expr</code></a> for roles of arguments.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_program"><a href="#val-pp_program" class="anchor"></a><code><span><span class="keyword">val</span> pp_program : <span>bool <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-req">req</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty printer of a program, see <a href="#val-pp_expr"><code>pp_expr</code></a> for roles of arguments.</p></div></div></div></body></html>
